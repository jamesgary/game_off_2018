<!DOCTYPE html>
<html>
  <head>
    <title>GAME</title>
    <link rel="stylesheet" type="text/css" href="./css/main.css">
  </head>
  <body>
    <div id="pixi"></div>
    <div id="elm-container">
      <div id="elm"></div>
    </div>
    <div id="stats"></div>
    <script src="./js/pixi.min.js"></script>
    <script src="./js/pixi-viewport.js"></script>
    <script src="./js/main.js"></script>
    <script>
      window.graphics = {};

      let app;
      let viewport;
      let particleContainerContainer;
      let particleContainersByTextureName;
      let sprites = [];
      let textureNameToParticleGroupCache = {};

      graphics.init = function() {
        PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

        app = new PIXI.Application({
          width: window.innerWidth,
          height: window.innerHeight,
          roundPixels: true,
          resolution: 1,
        });
        document.getElementById("pixi").appendChild(app.view);

        viewport = new PIXI.extras.Viewport({
          screenWidth: window.innerWidth,
          screenHeight: window.innerHeight,
          worldWidth: 20,
          worldHeight: 20 * (window.innerHeight / window.innerWidth),

          // the interaction module is important for wheel() to
          // work properly when renderer.view is placed or scaled
          interaction: app.renderer.interaction
        });
        app.stage.addChild(viewport);

        particleContainerContainer = new PIXI.Container();
        viewport.addChild(particleContainerContainer);

        // debug stuff
        //let rectangle = new PIXI.Graphics();
        //rectangle.beginFill(0xFFCCFF);
        //rectangle.drawRect(-999, 0, 2000, 1); // x axis
        //rectangle.drawRect(0, -999, 1, 2000); // y axis
        //rectangle.endFill();
        //viewport.addChild(rectangle);
        // end debug stuff
      }

      function addSprite(spriteData) {
        let particleContainer = particleContainersByTextureName[spriteData.texture];

        // make sure there's a particle container
        if (!particleContainer) {
          let particleContainer = new PIXI.particles.ParticleContainer();

          // add to caches
          particleContainersByTextureName[spriteData.texture] = particleContainer;
          particleContainerContainer.addChild(particleContainer);
        }

        pixiSprite = particleContainer.addChild(
          new PIXI.Sprite.fromImage('images/' + textureKey + '.png')
        );

        return pixiSprite;
      }

      graphics.drawSprites = function(spritesData) {
        // reset numDrawnSprites for all particle containers
        let allPcs = particleContainerContainer.children;
        for (let i = 0; i < allPcs.length; i++) {
          allPcs[i].numDrawnSprites = 0;
        }

        for (let i = 0; i < spritesData.length; i++) {
          let spriteData = spritesData[i]

          let particleContainer = textureNameToParticleGroupCache[spriteData.texture];
          if (!particleContainer) {
            // make new particle container
            particleContainer = new PIXI.particles.ParticleContainer();
            particleContainer.numDrawnSprites = 0;
            // add to particleContainerContainer
            particleContainerContainer.addChild(particleContainer);
            // add to textureNameToParticleGroupCache
            textureNameToParticleGroupCache[spriteData.texture] = particleContainer;
          }

          let sprite;
          try {
            sprite = particleContainer.getChildAt(particleContainer.numDrawnSprites);
          } catch(e) {
            sprite = new PIXI.Sprite.fromImage('images/' + spriteData.texture + '.png')
            particleContainer.addChildAt(sprite, particleContainer.numDrawnSprites);
          }

          sprite.x = spriteData.x;
          sprite.y = spriteData.y;
          particleContainer.numDrawnSprites++;

          // get the particle container (add one of it doesn't exist)
          // update the first undrawn sprite (add one if it doesn't exist)
          // lastly, remove 
        }

        return;


        // group sprites by texture
        let textureNameToSprites = {};

        for (let sprite of sprites) {
          let spriteGroup = textureNameToSprites[sprite.texture];

          if (!spriteGroup) {
            let particleContainer = new PIXI.particles.ParticleContainer();
            textureNameToSprites[sprite.texture] = [];
            particleContainerContainer.addChild(particleContainer);
          }

          textureNameToSprites[sprite.texture].push(sprite);
        }

        // maybe remove from particleContainerContainer sprites not on map?

        // then iterate over textures
        for (let textureKey in textureNameToSprites) {
          //let particleContainer = textureNameToSprites[textureKey];
          //console.log(particleContainer);

          // NOiterate over sprites to draw
          let spritesToDraw = textureNameToSprites[textureKey];
          for (let i = 0; i < spritesToDraw.length; i++) {
            // filter in sprites for this texture
            let spriteToDraw = spritesToDraw[i];

            let particleContainer = particleContainerContainer.children[1];

            if (!particleContainer.children[i]) {
              particleContainer.addChildAt(
                new PIXI.Sprite.fromImage('images/' + textureKey + '.png')
              , i
              );
            }

            particleContainer.children[i].x = spriteToDraw.x;
            particleContainer.children[i].y = spriteToDraw.y;
          }
        }
      };
    </script>
    <script>
      function init() {
        var persistence;

        try {
          persistence = JSON.parse(localStorage.getItem("persistence"));

          if (!persistence) { fail() }
        } catch(e) {
          persistence = null;
          localStorage.removeItem("persistence");
        }

        graphics.init();

        var app = Elm.Main.init({
          node: document.getElementById('elm'),
          flags: {
            // CHANGE ME WHEN CHANGING FLAGS
            persistence: persistence,
            timestamp: Date.now(),
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
          }
        });

        app.ports.performEffects.subscribe(function(effects) {
          for (let i = 0; i < effects.length; i++) {
            let effect = effects[i];

            // CHANGE ME WHEN CHANGING EFFECTS
            switch (effect.id) {
              case "SAVE":
                console.log("savin");
                console.log(effect.persistence);
                localStorage.setItem("persistence", JSON.stringify(effect.persistence));
                break;
              case "HARD_RESET":
                console.log("hard resetin");
                localStorage.removeItem("persistence");
                break;
              case "MOVE_CAMERA":
                viewport.moveCenter(effect.x, effect.y);
                break;
              case "DRAW":
                graphics.drawSprites(effect.sprites);
                break;
              default:
                //console.error("unknown effect: " + JSON.stringify(effect));
            }
          }
        });

        (function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.getElementById("stats").appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()
      }

      init();
    </script>
  </body>
</html>
